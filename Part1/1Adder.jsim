.include "nominal.jsim"
.include "stdcell.jsim"
* .include "2dcheckoff_100ns.jsim"

* basic FA
* S = A xor B xor Cin
* Co = (A + B)Cin + AB
.subckt FA a b cin s co
Xs1 a b s1 xor
Xs2 s1 cin s xor
Xc1 a b co1 nand2
Xc2 a cin co2 nand2
Xc3 b cin co3 nand2
Xc4 co1 co2 co3 co nand3
.ends

* make and with nand and inv
.subckt and a b z
Xzinv a b zinv nand2
Xz zinv z inverter
.ends

* faster xor with nands
.subckt xor a b z
X1 a b m nand2
X2 a m c nand2
X3 m b d nand2
X4 c d z nand2
.ends

* faster OR with nor and inv
.subckt or a b z
Xnor a b c nor2
Xinv c z inverter
.ends


* Single carry generate and carry propagate
* This will be used in the kogge-stone adder (KSA)

* G_i = A_i * B_i
* P_i = A_i xor B_i
.subckt PG a b g p
Xp a b p xor
Xg a b g and
.ends


* 1bit CLA
.subckt CLA1 a b cin g p s
Xs2 cin p s xor
Xgp a b g p PG
.ends


* this is for KSA, do refer to that diagram from the wikipedia page
* group propagate and generate
* G = Gi OR (Pi and Giprev)
* P = Pi AND Piprev
.subckt KSPG ph gh pl gl pout gout
Xpo ph pl pout and
Xgo1 ph gl phgl and
Xgo2 phgl gh gout or
.ends


* also for KSA, this is group generate, almost same as KSPG,
* except it is just group generate only.
* G = Gi OR (Pi and Giprev)
.subckt KSG ph gh gl gout
Xgo1 ph gl phgl and
Xgo2 phgl gh gout or
.ends


* for KSA, finds the sum Si
* Si = Pi XOR Ciprev
.subckt KSS ph cl s
Xs ph cl s xor
.ends
